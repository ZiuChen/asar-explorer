{"version":3,"file":"worker-CT2nJRkM.js","names":["json: Metadata | undefined","header: DirectoryMetadata","tree: UnpackedFiles","result: DirectoryMetadata","result: Uint8Array[]","files: UnpackedFiles","response: WorkerResponse","result: Record<string, ArrayBuffer>","transfers: ArrayBuffer[]"],"sources":["../../src/lib/asar-browser/utils.ts","../../src/lib/asar-browser/extractor.ts","../../src/lib/asar-browser/pickle.ts","../../src/lib/asar-browser/packager.ts","../../src/lib/asar-browser/worker.ts"],"sourcesContent":["/**\n * ASAR Browser Utils\n */\n\nimport type { DirectoryMetadata, FileMetadata } from './types'\n\n/** 检查值是否为目录（对象类型） */\nexport const isDirectory = (val: unknown): val is Record<string, unknown> =>\n  !!val &&\n  typeof val === 'object' &&\n  !ArrayBuffer.isView(val) &&\n  !(val instanceof ArrayBuffer) &&\n  !(val instanceof Blob)\n\n/** 检查元数据是否为目录元数据 */\nexport const isDirectoryMetadata = (\n  val: DirectoryMetadata | FileMetadata\n): val is DirectoryMetadata => isDirectory(val) && 'files' in val && isDirectory(val.files)\n\n/** 路径分隔符 */\nexport const PATH_SEP = '/'\n\n/** 连接路径 */\nexport const joinPath = (...parts: string[]): string => {\n  return parts.filter(Boolean).join(PATH_SEP).replace(/\\/+/g, PATH_SEP)\n}\n\n/** 获取路径的目录名 */\nexport const dirname = (p: string): string => {\n  const parts = p.split(PATH_SEP).filter(Boolean)\n  parts.pop()\n  return parts.join(PATH_SEP) || '.'\n}\n\n/** 获取路径的文件名 */\nexport const basename = (p: string): string => {\n  const parts = p.split(PATH_SEP).filter(Boolean)\n  return parts[parts.length - 1] || ''\n}\n","/**\n * ASAR Extractor - 提取 ASAR 文件内容\n * 基于 https://github.com/Banou26/asar-browser\n */\n\nimport type {\n  FileData,\n  DirectoryMetadata,\n  FileMetadata,\n  Metadata,\n  FullFileMetadata,\n  ListPackageMetadataReturn,\n  AsarHeader,\n  ExtractPackageReturn\n} from './types'\n\n// 重导出类型供其他模块使用\nexport type { FullFileMetadata } from './types'\n\nimport { isDirectoryMetadata, joinPath, dirname, basename, PATH_SEP } from './utils'\n\n/** 列表选项 */\nexport interface ListPackageOptions {\n  flat?: boolean\n}\n\n/** 将 FileData 转换为 ArrayBuffer */\nconst getArrayBuffer = async (data: FileData): Promise<ArrayBuffer> => {\n  if (data instanceof ArrayBuffer) {\n    return data\n  }\n  if (data instanceof Uint8Array) {\n    // 创建一个新的 ArrayBuffer 副本\n    const copy = new Uint8Array(data)\n    return copy.buffer as ArrayBuffer\n  }\n  if (data instanceof Blob) {\n    return data.arrayBuffer()\n  }\n  // string\n  return new Blob([data]).arrayBuffer()\n}\n\n/** 扁平化列出子元数据 */\nconst flatListChildMetadata = ({\n  basePath,\n  metadata,\n  filesOffset\n}: {\n  basePath: string\n  metadata: DirectoryMetadata\n  filesOffset: number\n}): FullFileMetadata[] =>\n  Object.entries(metadata.files).flatMap(([key, value]) =>\n    isDirectoryMetadata(value)\n      ? flatListChildMetadata({\n          basePath: joinPath(basePath, key),\n          metadata: value,\n          filesOffset\n        })\n      : {\n          path: joinPath(basePath, key),\n          offset: Number((value as FileMetadata).offset),\n          size: (value as FileMetadata).size,\n          fileOffset: filesOffset + 8 + Number((value as FileMetadata).offset)\n        }\n  )\n\n/** 嵌套列出子元数据 */\nconst listChildsNestedMetadata = ({\n  basePath,\n  metadata,\n  filesOffset\n}: {\n  basePath: string\n  metadata: DirectoryMetadata | FileMetadata\n  filesOffset: number\n}): ListPackageMetadataReturn | FullFileMetadata => {\n  if (isDirectoryMetadata(metadata)) {\n    return Object.fromEntries(\n      Object.entries(metadata.files).map(([key, value]) => [\n        key,\n        listChildsNestedMetadata({\n          basePath: joinPath(basePath, key),\n          metadata: value,\n          filesOffset\n        })\n      ])\n    ) as ListPackageMetadataReturn\n  }\n  return {\n    path: basePath,\n    offset: Number(metadata.offset),\n    size: metadata.size,\n    fileOffset: filesOffset + 8 + Number(metadata.offset)\n  } as FullFileMetadata\n}\n\n/** 根据选项列出子项 */\nconst listChilds = <T extends boolean>({\n  flat,\n  header,\n  filesOffset\n}: {\n  flat: T\n  header: DirectoryMetadata\n  filesOffset: number\n}): T extends true ? FullFileMetadata[] : ListPackageMetadataReturn =>\n  (flat\n    ? flatListChildMetadata({ metadata: header, basePath: '/', filesOffset })\n    : listChildsNestedMetadata({\n        metadata: header,\n        basePath: '/',\n        filesOffset\n      })) as T extends true ? FullFileMetadata[] : ListPackageMetadataReturn\n\n/** 从目录中搜索节点 */\nconst searchNodeFromDirectory = (header: Metadata, p: string): Metadata | undefined => {\n  let json: Metadata | undefined = header\n  const dirs = p.split(PATH_SEP).filter(Boolean)\n  for (const dir of dirs) {\n    if (dir !== '.' && json) {\n      json = (json as DirectoryMetadata).files?.[dir]\n    }\n  }\n  return json\n}\n\n/** 从路径中搜索节点 */\nconst searchNodeFromPath = (\n  header: DirectoryMetadata,\n  p: string\n): FileMetadata | DirectoryMetadata => {\n  p = p.replace(/^\\//, '')\n  if (!p) {\n    return header\n  }\n  const name = basename(p)\n  const node = searchNodeFromDirectory(header, dirname(p)) as DirectoryMetadata\n  if (!node.files) {\n    node.files = {}\n  }\n  if (!node.files[name]) {\n    node.files[name] = {}\n  }\n  return node.files[name]\n}\n\n/** 同步读取 ASAR 头部 */\nexport const readArchiveHeaderSync = (\n  archiveArrayBuffer: ArrayBuffer\n): { header: DirectoryMetadata; headerSize: number } => {\n  const dataView = new DataView(archiveArrayBuffer)\n  const size = dataView.getUint32(4, true)\n  const headerSize = dataView.getInt32(12, true)\n  const headerBytes = new Uint8Array(archiveArrayBuffer, 16, headerSize)\n  const header = new TextDecoder('utf-8').decode(headerBytes)\n  return {\n    header: JSON.parse(header),\n    headerSize: size\n  }\n}\n\n/** 提取单个文件 */\nexport const extractFile = async (archive: FileData, pathname: string): Promise<ArrayBuffer> => {\n  const buffer = await getArrayBuffer(archive)\n  const dataView = new DataView(buffer)\n  const size = dataView.getUint32(4, true)\n  const headerSize = dataView.getUint32(12, true)\n  const headerBuffer = buffer.slice(16, headerSize + 16)\n  const headerString = new TextDecoder('utf-8').decode(headerBuffer)\n  const header: DirectoryMetadata = JSON.parse(headerString)\n  const node = searchNodeFromPath(header, pathname) as FileMetadata\n  const { offset, size: payloadSize } = node\n  return buffer.slice(size + Number(offset) + 8, size + Number(offset) + (payloadSize || 0) + 8)\n}\n\n/** 获取 ASAR 头部信息 */\nexport const getHeader = async <T extends ListPackageOptions>(\n  bodyInit: FileData,\n  options?: T\n): Promise<AsarHeader<NonNullable<T['flat']>>> => {\n  const buffer = await getArrayBuffer(bodyInit)\n  const dataView = new DataView(buffer)\n  const size = dataView.getUint32(4, true)\n  const headerSize = dataView.getUint32(12, true)\n  const headerBuffer = buffer.slice(16, headerSize + 16)\n  const headerString = new TextDecoder('utf-8').decode(headerBuffer)\n  const header: DirectoryMetadata = JSON.parse(headerString)\n\n  return {\n    headerSize,\n    filesOffset: size,\n    header: listChilds({\n      flat: options?.flat ?? false,\n      header,\n      filesOffset: size\n    })\n  } as AsarHeader<NonNullable<T['flat']>>\n}\n\n/** 获取原始头部 JSON */\nexport const getRawHeader = async (archive: FileData): Promise<DirectoryMetadata> => {\n  const buffer = await getArrayBuffer(archive)\n  const dataView = new DataView(buffer)\n  const headerSize = dataView.getUint32(12, true)\n  const headerBuffer = buffer.slice(16, headerSize + 16)\n  const headerString = new TextDecoder('utf-8').decode(headerBuffer)\n  return JSON.parse(headerString)\n}\n\n/** 列出包内所有文件路径 */\nexport const listPackage = async (archive: FileData): Promise<string[]> => {\n  const { header } = await getHeader(archive, { flat: true })\n  return (header as FullFileMetadata[]).map((f) => f.path)\n}\n\n/** 提取所有文件 */\nexport const extractAll = async <T extends ListPackageOptions>(\n  archive: FileData,\n  options?: T\n): Promise<{ [key: string]: ArrayBuffer } | ExtractPackageReturn> => {\n  const buffer = await getArrayBuffer(archive)\n  const { header } = await getHeader(buffer, { flat: options?.flat })\n\n  if (options?.flat) {\n    return Object.fromEntries(\n      await Promise.all(\n        (header as FullFileMetadata[]).map(async ({ path }) => [\n          path,\n          await extractFile(buffer, path)\n        ])\n      )\n    )\n  }\n\n  const extractFolder = async (folder: ListPackageMetadataReturn): Promise<ExtractPackageReturn> =>\n    Object.fromEntries(\n      await Promise.all(\n        Object.entries(folder).map(async ([key, value]) => {\n          if ('path' in value) {\n            // It's a FullFileMetadata\n            return [key, await extractFile(buffer, (value as FullFileMetadata).path)]\n          } else {\n            // It's a nested folder\n            return [key, await extractFolder(value as ListPackageMetadataReturn)]\n          }\n        })\n      )\n    )\n\n  return extractFolder(header as ListPackageMetadataReturn)\n}\n\n/** 读取文件为文本 */\nexport const readFileAsText = async (archive: FileData, pathname: string): Promise<string> => {\n  const buffer = await extractFile(archive, pathname)\n  return new TextDecoder('utf-8').decode(buffer)\n}\n\n/** 读取文件为 Uint8Array */\nexport const readFileAsUint8Array = async (\n  archive: FileData,\n  pathname: string\n): Promise<Uint8Array> => {\n  const buffer = await extractFile(archive, pathname)\n  return new Uint8Array(buffer)\n}\n","/**\n * Pickle - Binary value packing and unpacking\n * 基于 https://github.com/electron/asar 的 Pickle 实现\n * 移除了 Buffer 依赖，使用原生 ArrayBuffer/DataView\n */\n\n// sizeof(T)\nexport const SIZE_INT32 = 4\nexport const SIZE_UINT32 = 4\nexport const SIZE_FLOAT = 4\nexport const SIZE_DOUBLE = 8\n\n// The allocation granularity of the payload\nexport const PAYLOAD_UNIT = 64\n\n// Largest JS number\nexport const CAPACITY_READ_ONLY = 9007199254740992\n\n// Aligns 'i' by rounding it up to the next multiple of 'alignment'\nexport const alignInt = (i: number, alignment: number): number =>\n  i + ((alignment - (i % alignment)) % alignment)\n\n/**\n * PickleIterator reads data from a Pickle\n */\nclass PickleIterator {\n  private payload: Uint8Array\n  private dataView: DataView\n  private payloadOffset: number\n  private readIndex: number\n  private endIndex: number\n\n  constructor(pickle: Pickle) {\n    this.payload = pickle.header\n    this.dataView = new DataView(\n      pickle.header.buffer,\n      pickle.header.byteOffset,\n      pickle.header.byteLength\n    )\n    this.payloadOffset = pickle.headerSize\n    this.readIndex = 0\n    this.endIndex = pickle.getPayloadSize()\n  }\n\n  readBool(): boolean {\n    return this.readInt() !== 0\n  }\n\n  readInt(): number {\n    return this.readBytesAsNumber(SIZE_INT32, true)\n  }\n\n  readUInt32(): number {\n    return this.readBytesAsNumber(SIZE_UINT32, false)\n  }\n\n  readFloat(): number {\n    const offset = this.getReadPayloadOffsetAndAdvance(SIZE_FLOAT)\n    return this.dataView.getFloat32(offset, true)\n  }\n\n  readDouble(): number {\n    const offset = this.getReadPayloadOffsetAndAdvance(SIZE_DOUBLE)\n    return this.dataView.getFloat64(offset, true)\n  }\n\n  readString(): string {\n    const length = this.readInt()\n    const bytes = this.readBytes(length)\n    return new TextDecoder('utf-8').decode(bytes)\n  }\n\n  readBytes(length: number): Uint8Array {\n    const readPayloadOffset = this.getReadPayloadOffsetAndAdvance(length)\n    return this.payload.slice(readPayloadOffset, readPayloadOffset + length)\n  }\n\n  private readBytesAsNumber(size: number, signed: boolean): number {\n    const offset = this.getReadPayloadOffsetAndAdvance(size)\n    if (size === SIZE_INT32) {\n      return signed ? this.dataView.getInt32(offset, true) : this.dataView.getUint32(offset, true)\n    }\n    throw new Error(`Unsupported size: ${size}`)\n  }\n\n  private getReadPayloadOffsetAndAdvance(length: number): number {\n    if (length > this.endIndex - this.readIndex) {\n      this.readIndex = this.endIndex\n      throw new Error('Failed to read data with length of ' + length)\n    }\n    const readPayloadOffset = this.payloadOffset + this.readIndex\n    this.advance(length)\n    return readPayloadOffset\n  }\n\n  private advance(size: number): void {\n    const alignedSize = alignInt(size, SIZE_UINT32)\n    if (this.endIndex - this.readIndex < alignedSize) {\n      this.readIndex = this.endIndex\n    } else {\n      this.readIndex += alignedSize\n    }\n  }\n}\n\n/**\n * Pickle class provides facilities for basic binary value packing and unpacking\n */\nexport default class Pickle {\n  header: Uint8Array\n  headerSize: number\n  private dataView: DataView\n  private capacityAfterHeader: number\n  private writeOffset: number\n\n  constructor(buffer?: Uint8Array) {\n    if (buffer) {\n      this.header = buffer\n      this.dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n      this.headerSize = buffer.length - this.getPayloadSize()\n      this.capacityAfterHeader = CAPACITY_READ_ONLY\n      this.writeOffset = 0\n      if (this.headerSize > buffer.length) {\n        this.headerSize = 0\n      }\n      if (this.headerSize !== alignInt(this.headerSize, SIZE_UINT32)) {\n        this.headerSize = 0\n      }\n      if (this.headerSize === 0) {\n        this.header = new Uint8Array(0)\n        this.dataView = new DataView(this.header.buffer)\n      }\n    } else {\n      this.header = new Uint8Array(0)\n      this.dataView = new DataView(this.header.buffer)\n      this.headerSize = SIZE_UINT32\n      this.capacityAfterHeader = 0\n      this.writeOffset = 0\n      this.resize(PAYLOAD_UNIT)\n      this.setPayloadSize(0)\n    }\n  }\n\n  createIterator(): PickleIterator {\n    return new PickleIterator(this)\n  }\n\n  toBuffer(): Uint8Array {\n    return this.header.slice(0, this.headerSize + this.getPayloadSize())\n  }\n\n  writeBool(value: boolean): boolean {\n    return this.writeInt(value ? 1 : 0)\n  }\n\n  writeInt(value: number): boolean {\n    return this.writeNumber(value, SIZE_INT32, true)\n  }\n\n  writeUInt32(value: number): boolean {\n    return this.writeNumber(value, SIZE_UINT32, false)\n  }\n\n  writeFloat(value: number): boolean {\n    const dataLength = alignInt(SIZE_FLOAT, SIZE_UINT32)\n    const newSize = this.writeOffset + dataLength\n    if (newSize > this.capacityAfterHeader) {\n      this.resize(Math.max(this.capacityAfterHeader * 2, newSize))\n    }\n    this.dataView.setFloat32(this.headerSize + this.writeOffset, value, true)\n    this.fillZeros(SIZE_FLOAT, dataLength)\n    this.setPayloadSize(newSize)\n    this.writeOffset = newSize\n    return true\n  }\n\n  writeDouble(value: number): boolean {\n    const dataLength = alignInt(SIZE_DOUBLE, SIZE_UINT32)\n    const newSize = this.writeOffset + dataLength\n    if (newSize > this.capacityAfterHeader) {\n      this.resize(Math.max(this.capacityAfterHeader * 2, newSize))\n    }\n    this.dataView.setFloat64(this.headerSize + this.writeOffset, value, true)\n    this.fillZeros(SIZE_DOUBLE, dataLength)\n    this.setPayloadSize(newSize)\n    this.writeOffset = newSize\n    return true\n  }\n\n  writeString(value: string): boolean {\n    const encoded = new TextEncoder().encode(value)\n    const length = encoded.length\n    if (!this.writeInt(length)) {\n      return false\n    }\n    return this.writeBytes(encoded, length)\n  }\n\n  setPayloadSize(payloadSize: number): void {\n    this.dataView.setUint32(0, payloadSize, true)\n  }\n\n  getPayloadSize(): number {\n    if (this.header.length < 4) return 0\n    return this.dataView.getUint32(0, true)\n  }\n\n  private writeNumber(value: number, size: number, signed: boolean): boolean {\n    const dataLength = alignInt(size, SIZE_UINT32)\n    const newSize = this.writeOffset + dataLength\n    if (newSize > this.capacityAfterHeader) {\n      this.resize(Math.max(this.capacityAfterHeader * 2, newSize))\n    }\n    if (signed) {\n      this.dataView.setInt32(this.headerSize + this.writeOffset, value, true)\n    } else {\n      this.dataView.setUint32(this.headerSize + this.writeOffset, value, true)\n    }\n    this.fillZeros(size, dataLength)\n    this.setPayloadSize(newSize)\n    this.writeOffset = newSize\n    return true\n  }\n\n  private writeBytes(data: Uint8Array, length: number): boolean {\n    const dataLength = alignInt(length, SIZE_UINT32)\n    const newSize = this.writeOffset + dataLength\n    if (newSize > this.capacityAfterHeader) {\n      this.resize(Math.max(this.capacityAfterHeader * 2, newSize))\n    }\n    this.header.set(data, this.headerSize + this.writeOffset)\n    this.fillZeros(length, dataLength)\n    this.setPayloadSize(newSize)\n    this.writeOffset = newSize\n    return true\n  }\n\n  private fillZeros(start: number, end: number): void {\n    const endOffset = this.headerSize + this.writeOffset + start\n    for (let i = endOffset; i < this.headerSize + this.writeOffset + end; i++) {\n      this.header[i] = 0\n    }\n  }\n\n  private resize(newCapacity: number): void {\n    newCapacity = alignInt(newCapacity, PAYLOAD_UNIT)\n    const newHeader = new Uint8Array(this.headerSize + newCapacity)\n    newHeader.set(this.header)\n    this.header = newHeader\n    this.dataView = new DataView(newHeader.buffer, newHeader.byteOffset, newHeader.byteLength)\n    this.capacityAfterHeader = newCapacity\n  }\n}\n\nexport const createEmpty = (): Pickle => new Pickle()\n\nexport const createFromBuffer = (buffer: Uint8Array): Pickle => new Pickle(buffer)\n","/**\n * ASAR Packager - 创建 ASAR 文件\n * 基于 https://github.com/Banou26/asar-browser\n */\n\nimport type { UnpackedFiles, FileMetadata, DirectoryMetadata, FileData } from './types'\n\nimport { createEmpty } from './pickle'\nimport { isDirectory, isDirectoryMetadata, PATH_SEP } from './utils'\n\n/** 将扁平路径树转换为嵌套树 */\nconst makeFlatTree = (files: UnpackedFiles): UnpackedFiles => {\n  const tree: UnpackedFiles = {}\n\n  for (const [key, val] of Object.entries(files)) {\n    let currDir = tree\n    const dirs = key.split(PATH_SEP).filter(Boolean)\n    const filename = dirs.pop() as string\n    for (const dir of dirs) {\n      currDir = (currDir[dir] = currDir[dir] ?? {}) as UnpackedFiles\n    }\n    currDir[filename] = val\n  }\n  return tree\n}\n\n/** 创建头部树结构 */\nconst makeHeaderTree = (files: UnpackedFiles): { files: Record<string, unknown> } =>\n  Object.entries(files).reduce(\n    ({ files }, [key, value]) => ({\n      files: {\n        ...files,\n        [key]: isDirectory(value) ? makeHeaderTree(value as UnpackedFiles) : value\n      }\n    }),\n    { files: {} }\n  )\n\n/** 将 FileData 转换为 Uint8Array */\nconst toUint8Array = async (data: FileData): Promise<Uint8Array> => {\n  if (data instanceof Uint8Array) {\n    return data\n  }\n  if (data instanceof ArrayBuffer) {\n    return new Uint8Array(data)\n  }\n  if (data instanceof Blob) {\n    const buffer = await data.arrayBuffer()\n    return new Uint8Array(buffer)\n  }\n  // string\n  return new TextEncoder().encode(data)\n}\n\n/** 计算每个文件的大小 */\nconst makeSizeTree = async (tree: {\n  files: Record<string, unknown>\n}): Promise<DirectoryMetadata> => {\n  const result: DirectoryMetadata = { files: {} }\n\n  for (const [key, value] of Object.entries(tree.files)) {\n    if (isDirectory(value) && 'files' in (value as Record<string, unknown>)) {\n      result.files[key] = await makeSizeTree(value as { files: Record<string, unknown> })\n    } else {\n      const data = await toUint8Array(value as FileData)\n      result.files[key] = { size: data.length } as FileMetadata\n    }\n  }\n\n  return result\n}\n\n/** 为每个文件添加偏移量 */\nconst makeOffsetTree = (tree: DirectoryMetadata): DirectoryMetadata => {\n  const makeInnerOffsetTree = (\n    tree: DirectoryMetadata,\n    offset: string\n  ): [DirectoryMetadata, string] =>\n    Object.entries(tree.files).reduce<[DirectoryMetadata, string]>(\n      ([{ files }, currentOffset], [key, value]) => {\n        const [newValue, newOffset] = isDirectoryMetadata(value)\n          ? makeInnerOffsetTree(value, currentOffset)\n          : [\n              {\n                size: (value as FileMetadata).size || 0,\n                offset: currentOffset\n              } as FileMetadata,\n              (Number(currentOffset) + ((value as FileMetadata).size || 0)).toString()\n            ]\n\n        return [\n          {\n            files: {\n              ...files,\n              [key]: newValue\n            }\n          },\n          newOffset\n        ]\n      },\n      [{ files: {} }, offset || '0']\n    )\n\n  return makeInnerOffsetTree(tree, '0')[0]\n}\n\n/** 创建头部元数据 */\nconst makeHeader = async (files: UnpackedFiles): Promise<DirectoryMetadata> =>\n  makeOffsetTree(await makeSizeTree(makeHeaderTree(files)))\n\n/** 递归收集所有文件数据 */\nconst makeFilesBuffer = async (files: UnpackedFiles): Promise<Uint8Array[]> => {\n  const result: Uint8Array[] = []\n\n  for (const [, value] of Object.entries(files)) {\n    if (isDirectory(value)) {\n      const nested = await makeFilesBuffer(value as UnpackedFiles)\n      result.push(...nested)\n    } else {\n      result.push(await toUint8Array(value as FileData))\n    }\n  }\n\n  return result\n}\n\n/** 创建 ASAR 包选项 */\nexport interface CreatePackageOptions {\n  flat?: boolean\n}\n\n/**\n * 创建 ASAR 包\n * @param files 文件结构，可以是嵌套对象或扁平路径\n * @param options 选项\n * @returns ASAR 文件的 Uint8Array\n */\nexport const createPackage = async (\n  files: UnpackedFiles,\n  options?: CreatePackageOptions\n): Promise<Uint8Array> => {\n  const normalizedFiles = options?.flat ? makeFlatTree(files) : files\n  const header = await makeHeader(normalizedFiles)\n  const headerPickle = createEmpty()\n  headerPickle.writeString(JSON.stringify(header))\n  const headerBuf = headerPickle.toBuffer()\n\n  const sizePickle = createEmpty()\n  sizePickle.writeUInt32(headerBuf.length)\n  const sizeBuf = sizePickle.toBuffer()\n\n  const fileBuffers = await makeFilesBuffer(normalizedFiles)\n\n  // 计算总长度\n  const totalLength =\n    sizeBuf.length + headerBuf.length + fileBuffers.reduce((sum, buf) => sum + buf.length, 0)\n\n  // 合并所有缓冲区\n  const result = new Uint8Array(totalLength)\n  let offset = 0\n\n  result.set(sizeBuf, offset)\n  offset += sizeBuf.length\n\n  result.set(headerBuf, offset)\n  offset += headerBuf.length\n\n  for (const buf of fileBuffers) {\n    result.set(buf, offset)\n    offset += buf.length\n  }\n\n  return result\n}\n\n/**\n * 修改 ASAR 包中的文件\n * 通过解压所有文件，修改指定文件，然后重新打包\n * @param archive 原始 ASAR 数据\n * @param modifications 要修改的文件，键为路径，值为新内容\n * @returns 新的 ASAR 文件 Uint8Array\n */\nexport const modifyPackage = async (\n  archive: FileData,\n  modifications: Record<string, FileData>\n): Promise<Uint8Array> => {\n  // 动态导入 extractor 以避免循环依赖\n  const { getHeader, extractFile } = await import('./extractor')\n\n  const { header } = await getHeader(archive, { flat: true })\n  const flatHeader = header as Array<{ path: string }>\n\n  // 提取所有文件\n  const files: UnpackedFiles = {}\n  for (const { path } of flatHeader) {\n    const content = await extractFile(archive, path)\n    // 使用扁平路径（移除开头的 /）\n    const normalizedPath = path.replace(/^\\//, '')\n    files[normalizedPath] = new Uint8Array(content)\n  }\n\n  // 应用修改\n  for (const [path, content] of Object.entries(modifications)) {\n    const normalizedPath = path.replace(/^\\//, '')\n    files[normalizedPath] = content\n  }\n\n  // 重新打包\n  return createPackage(files, { flat: true })\n}\n\n/**\n * 添加文件到 ASAR 包\n * @param archive 原始 ASAR 数据\n * @param newFiles 要添加的文件\n * @returns 新的 ASAR 文件 Uint8Array\n */\nexport const addFilesToPackage = async (\n  archive: FileData,\n  newFiles: Record<string, FileData>\n): Promise<Uint8Array> => {\n  return modifyPackage(archive, newFiles)\n}\n\n/**\n * 从 ASAR 包删除文件\n * @param archive 原始 ASAR 数据\n * @param pathsToDelete 要删除的文件路径数组\n * @returns 新的 ASAR 文件 Uint8Array\n */\nexport const deleteFilesFromPackage = async (\n  archive: FileData,\n  pathsToDelete: string[]\n): Promise<Uint8Array> => {\n  const { getHeader, extractFile } = await import('./extractor')\n\n  const { header } = await getHeader(archive, { flat: true })\n  const flatHeader = header as Array<{ path: string }>\n\n  // 规范化要删除的路径\n  const normalizedPathsToDelete = new Set(pathsToDelete.map((p) => p.replace(/^\\//, '')))\n\n  // 提取除要删除的文件外的所有文件\n  const files: UnpackedFiles = {}\n  for (const { path } of flatHeader) {\n    const normalizedPath = path.replace(/^\\//, '')\n    if (!normalizedPathsToDelete.has(normalizedPath)) {\n      const content = await extractFile(archive, path)\n      files[normalizedPath] = new Uint8Array(content)\n    }\n  }\n\n  // 重新打包\n  return createPackage(files, { flat: true })\n}\n","/**\n * ASAR Worker - 在 WebWorker 中处理 ASAR 解析和打包\n * 避免阻塞主线程\n */\n\nimport { getHeader, extractFile } from './extractor'\nimport type { FullFileMetadata } from './types'\nimport { modifyPackage } from './packager'\n\nexport type WorkerRequest =\n  | { type: 'parseHeader'; id: number; data: ArrayBuffer }\n  | { type: 'extractFile'; id: number; data: ArrayBuffer; path: string }\n  | { type: 'extractFiles'; id: number; data: ArrayBuffer; paths: string[] }\n  | {\n      type: 'modifyPackage'\n      id: number\n      data: ArrayBuffer\n      modifications: Record<string, Uint8Array>\n    }\n\nexport type WorkerResponse =\n  | { type: 'parseHeader'; id: number; result: { files: FullFileMetadata[]; filesOffset: number } }\n  | { type: 'extractFile'; id: number; result: ArrayBuffer }\n  | { type: 'extractFiles'; id: number; result: Record<string, ArrayBuffer> }\n  | { type: 'modifyPackage'; id: number; result: Uint8Array }\n  | { type: 'error'; id: number; error: string }\n\nself.onmessage = async (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data\n\n  try {\n    switch (request.type) {\n      case 'parseHeader': {\n        const { header, filesOffset } = await getHeader(request.data, { flat: true })\n        const response: WorkerResponse = {\n          type: 'parseHeader',\n          id: request.id,\n          result: { files: header as FullFileMetadata[], filesOffset }\n        }\n        self.postMessage(response)\n        break\n      }\n\n      case 'extractFile': {\n        const result = await extractFile(request.data, request.path)\n        const response: WorkerResponse = {\n          type: 'extractFile',\n          id: request.id,\n          result\n        }\n        self.postMessage(response, { transfer: [result] })\n        break\n      }\n\n      case 'extractFiles': {\n        const result: Record<string, ArrayBuffer> = {}\n        const transfers: ArrayBuffer[] = []\n        for (const path of request.paths) {\n          const buffer = await extractFile(request.data, path)\n          result[path] = buffer\n          transfers.push(buffer)\n        }\n        const response: WorkerResponse = {\n          type: 'extractFiles',\n          id: request.id,\n          result\n        }\n        self.postMessage(response, { transfer: transfers })\n        break\n      }\n\n      case 'modifyPackage': {\n        const result = await modifyPackage(request.data, request.modifications)\n        const response: WorkerResponse = {\n          type: 'modifyPackage',\n          id: request.id,\n          result\n        }\n        self.postMessage(response, { transfer: [result.buffer] })\n        break\n      }\n    }\n  } catch (e) {\n    const response: WorkerResponse = {\n      type: 'error',\n      id: request.id,\n      error: e instanceof Error ? e.message : String(e)\n    }\n    self.postMessage(response)\n  }\n}\n"],"mappings":"qKAOa,EAAe,GAC1B,CAAC,CAAC,GACF,OAAO,GAAQ,UACf,CAAC,YAAY,OAAO,EAAI,EACxB,EAAE,aAAe,cACjB,EAAE,aAAe,MAGN,EACX,GAC6B,EAAY,EAAI,EAAI,UAAW,GAAO,EAAY,EAAI,MAAM,CAG9E,EAAW,IAGX,GAAY,GAAG,IACnB,EAAM,OAAO,QAAQ,CAAC,KAAK,EAAS,CAAC,QAAQ,OAAQ,EAAS,CAI1D,EAAW,GAAsB,CAC5C,IAAM,EAAQ,EAAE,MAAM,EAAS,CAAC,OAAO,QAAQ,CAE/C,OADA,EAAM,KAAK,CACJ,EAAM,KAAK,EAAS,EAAI,KAIpB,EAAY,GAAsB,CAC7C,IAAM,EAAQ,EAAE,MAAM,EAAS,CAAC,OAAO,QAAQ,CAC/C,OAAO,EAAM,EAAM,OAAS,IAAM,2NClBuC,CAQrE,EAAiB,KAAO,IACxB,aAAgB,YACX,EAEL,aAAgB,WAEL,IAAI,WAAW,EAAK,CACrB,OAEV,aAAgB,KACX,EAAK,aAAa,CAGpB,IAAI,KAAK,CAAC,EAAK,CAAC,CAAC,aAAa,CAIjC,GAAyB,CAC7B,WACA,WACA,iBAMA,OAAO,QAAQ,EAAS,MAAM,CAAC,SAAS,CAAC,EAAK,KAC5C,EAAoB,EAAM,CACtB,EAAsB,CACpB,SAAU,EAAS,EAAU,EAAI,CACjC,SAAU,EACV,cACD,CAAC,CACF,CACE,KAAM,EAAS,EAAU,EAAI,CAC7B,OAAQ,OAAQ,EAAuB,OAAO,CAC9C,KAAO,EAAuB,KAC9B,WAAY,EAAc,EAAI,OAAQ,EAAuB,OAAO,CACrE,CACN,CAGG,GAA4B,CAChC,WACA,WACA,iBAMI,EAAoB,EAAS,CACxB,OAAO,YACZ,OAAO,QAAQ,EAAS,MAAM,CAAC,KAAK,CAAC,EAAK,KAAW,CACnD,EACA,EAAyB,CACvB,SAAU,EAAS,EAAU,EAAI,CACjC,SAAU,EACV,cACD,CAAC,CACH,CAAC,CACH,CAEI,CACL,KAAM,EACN,OAAQ,OAAO,EAAS,OAAO,CAC/B,KAAM,EAAS,KACf,WAAY,EAAc,EAAI,OAAO,EAAS,OAAO,CACtD,CAIG,GAAiC,CACrC,OACA,SACA,iBAMC,EACG,EAAsB,CAAE,SAAU,EAAQ,SAAU,IAAK,cAAa,CAAC,CACvE,EAAyB,CACvB,SAAU,EACV,SAAU,IACV,cACD,CAAC,CAGF,GAA2B,EAAkB,IAAoC,CACrF,IAAIA,EAA6B,EAC3B,EAAO,EAAE,MAAM,EAAS,CAAC,OAAO,QAAQ,CAC9C,IAAK,IAAM,KAAO,EACZ,IAAQ,KAAO,IACjB,EAAQ,EAA2B,QAAQ,IAG/C,OAAO,GAIH,GACJ,EACA,IACqC,CAErC,GADA,EAAI,EAAE,QAAQ,MAAO,GAAG,CACpB,CAAC,EACH,OAAO,EAET,IAAM,EAAO,EAAS,EAAE,CAClB,EAAO,EAAwB,EAAQ,EAAQ,EAAE,CAAC,CAOxD,MANA,CACE,EAAK,QAAQ,EAAE,CAEZ,EAAK,MAAM,KACd,EAAK,MAAM,GAAQ,EAAE,EAEhB,EAAK,MAAM,IAIP,EACX,GACsD,CACtD,IAAM,EAAW,IAAI,SAAS,EAAmB,CAC3C,EAAO,EAAS,UAAU,EAAG,GAAK,CAClC,EAAa,EAAS,SAAS,GAAI,GAAK,CACxC,EAAc,IAAI,WAAW,EAAoB,GAAI,EAAW,CAChE,EAAS,IAAI,YAAY,QAAQ,CAAC,OAAO,EAAY,CAC3D,MAAO,CACL,OAAQ,KAAK,MAAM,EAAO,CAC1B,WAAY,EACb,EAIU,EAAc,MAAO,EAAmB,IAA2C,CAC9F,IAAM,EAAS,MAAM,EAAe,EAAQ,CACtC,EAAW,IAAI,SAAS,EAAO,CAC/B,EAAO,EAAS,UAAU,EAAG,GAAK,CAClC,EAAa,EAAS,UAAU,GAAI,GAAK,CACzC,EAAe,EAAO,MAAM,GAAI,EAAa,GAAG,CAChD,EAAe,IAAI,YAAY,QAAQ,CAAC,OAAO,EAAa,CAG5D,CAAE,SAAQ,KAAM,GADT,EADqB,KAAK,MAAM,EAAa,CAClB,EAAS,CAEjD,OAAO,EAAO,MAAM,EAAO,OAAO,EAAO,CAAG,EAAG,EAAO,OAAO,EAAO,EAAI,GAAe,GAAK,EAAE,EAInF,EAAY,MACvB,EACA,IACgD,CAChD,IAAM,EAAS,MAAM,EAAe,EAAS,CACvC,EAAW,IAAI,SAAS,EAAO,CAC/B,EAAO,EAAS,UAAU,EAAG,GAAK,CAClC,EAAa,EAAS,UAAU,GAAI,GAAK,CACzC,EAAe,EAAO,MAAM,GAAI,EAAa,GAAG,CAChD,EAAe,IAAI,YAAY,QAAQ,CAAC,OAAO,EAAa,CAC5DC,EAA4B,KAAK,MAAM,EAAa,CAE1D,MAAO,CACL,aACA,YAAa,EACb,OAAQ,EAAW,CACjB,KAAM,GAAS,MAAQ,GACvB,SACA,YAAa,EACd,CAAC,CACH,EAIU,EAAe,KAAO,IAAkD,CACnF,IAAM,EAAS,MAAM,EAAe,EAAQ,CAEtC,EADW,IAAI,SAAS,EAAO,CACT,UAAU,GAAI,GAAK,CACzC,EAAe,EAAO,MAAM,GAAI,EAAa,GAAG,CAChD,EAAe,IAAI,YAAY,QAAQ,CAAC,OAAO,EAAa,CAClE,OAAO,KAAK,MAAM,EAAa,EAIpB,EAAc,KAAO,IAAyC,CACzE,GAAM,CAAE,UAAW,MAAM,EAAU,EAAS,CAAE,KAAM,GAAM,CAAC,CAC3D,OAAQ,EAA8B,IAAK,GAAM,EAAE,KAAK,EAI7C,EAAa,MACxB,EACA,IACmE,CACnE,IAAM,EAAS,MAAM,EAAe,EAAQ,CACtC,CAAE,UAAW,MAAM,EAAU,EAAQ,CAAE,KAAM,GAAS,KAAM,CAAC,CAEnE,GAAI,GAAS,KACX,OAAO,OAAO,YACZ,MAAM,QAAQ,IACX,EAA8B,IAAI,MAAO,CAAE,UAAW,CACrD,EACA,MAAM,EAAY,EAAQ,EAAK,CAChC,CAAC,CACH,CACF,CAGH,IAAM,EAAgB,KAAO,IAC3B,OAAO,YACL,MAAM,QAAQ,IACZ,OAAO,QAAQ,EAAO,CAAC,IAAI,MAAO,CAAC,EAAK,KAClC,SAAU,EAEL,CAAC,EAAK,MAAM,EAAY,EAAS,EAA2B,KAAK,CAAC,CAGlE,CAAC,EAAK,MAAM,EAAc,EAAmC,CAAC,CAEvE,CACH,CACF,CAEH,OAAO,EAAc,EAAoC,EAI9C,EAAiB,MAAO,EAAmB,IAAsC,CAC5F,IAAM,EAAS,MAAM,EAAY,EAAS,EAAS,CACnD,OAAO,IAAI,YAAY,QAAQ,CAAC,OAAO,EAAO,EAInC,EAAuB,MAClC,EACA,IACwB,CACxB,IAAM,EAAS,MAAM,EAAY,EAAS,EAAS,CACnD,OAAO,IAAI,WAAW,EAAO,6DCzO3B,KAAA,QAAA,EAAA,OACA,KAAA,SAAA,IAAA,SAAA,EAAA,OAAA,OAAA,EAAA,OAAA,WAAA,EAAA,OAAA,WAAA,CAKA,KAAA,cAAA,EAAA,WACA,KAAA,UAAA,EACA,KAAA,SAAA,EAAA,gBAAA,YAIA,OAAA,KAAA,SAAA,GAAA,YAIA,OAAA,KAAA,kBAAA,EAAA,GAAA,cAIA,OAAA,KAAA,kBAAA,EAAA,GAAA,0DAKA,OAAA,KAAA,SAAA,WAAA,EAAA,GAAA,2DAKA,OAAA,KAAA,SAAA,WAAA,EAAA,GAAA,uDAMA,OAAA,IAAA,YAAA,QAAA,CAAA,OAAA,EAAA,2DAKA,OAAA,KAAA,QAAA,MAAA,EAAA,EAAA,EAAA,qEAKA,GAAA,IAAA,EAAA,OAAA,EAAA,KAAA,SAAA,SAAA,EAAA,GAAA,CAAA,KAAA,SAAA,UAAA,EAAA,GAAA,CAGA,MAAA,MAAA,qBAAA,IAAA,mCAIA,GAAA,EAAA,KAAA,SAAA,KAAA,UAEE,KADA,MAAA,UAAA,KAAA,SACA,MAAA,sCAAA,EAAA,yCAIF,OADA,KAAA,QAAA,EAAA,CACA,0BAKA,KAAA,SAAA,KAAA,UAAA,EAAA,KAAA,UAAA,KAAA,oDAmBA,GACE,KAAA,OAAA,EACA,KAAA,SAAA,IAAA,SAAA,EAAA,OAAA,EAAA,WAAA,EAAA,WAAA,CACA,KAAA,WAAA,EAAA,OAAA,KAAA,gBAAA,CACA,KAAA,oBAAA,iBACA,KAAA,YAAA,EACA,KAAA,WAAA,EAAA,SAAA,KAAA,WAAA,GAGA,KAAA,aAAA,EAAA,KAAA,WAAA,EAAA,GAAA,KAAA,WAAA,GAGA,KAAA,aAAA,IACE,KAAA,OAAA,IAAA,WACA,KAAA,SAAA,IAAA,SAAA,KAAA,OAAA,OAAA,IAGF,KAAA,OAAA,IAAA,WACA,KAAA,SAAA,IAAA,SAAA,KAAA,OAAA,OAAA,CACA,KAAA,WAAA,EACA,KAAA,oBAAA,EACA,KAAA,YAAA,EACA,KAAA,OAAA,GAAA,CACA,KAAA,eAAA,EAAA,mBAKF,OAAA,IAAA,EAAA,KAAA,YAIA,OAAA,KAAA,OAAA,MAAA,EAAA,KAAA,WAAA,KAAA,gBAAA,CAAA,cAIA,OAAA,KAAA,SAAA,EAAA,EAAA,EAAA,aAIA,OAAA,KAAA,YAAA,EAAA,EAAA,GAAA,gBAIA,OAAA,KAAA,YAAA,EAAA,EAAA,GAAA,iDAaA,OAPA,EAAA,KAAA,qBAAA,KAAA,OAAA,KAAA,IAAA,KAAA,oBAAA,EAAA,EAAA,CAAA,CAGA,KAAA,SAAA,WAAA,KAAA,WAAA,KAAA,YAAA,EAAA,GAAA,CACA,KAAA,UAAA,EAAA,EAAA,CACA,KAAA,eAAA,EAAA,CACA,KAAA,YAAA,EACA,oDAaA,OAPA,EAAA,KAAA,qBAAA,KAAA,OAAA,KAAA,IAAA,KAAA,oBAAA,EAAA,EAAA,CAAA,CAGA,KAAA,SAAA,WAAA,KAAA,WAAA,KAAA,YAAA,EAAA,GAAA,CACA,KAAA,UAAA,EAAA,EAAA,CACA,KAAA,eAAA,EAAA,CACA,KAAA,YAAA,EACA,+DASA,OAHA,KAAA,SAAA,EAAA,CAGA,KAAA,WAAA,EAAA,EAAA,CAHA,qBAOA,KAAA,SAAA,UAAA,EAAA,EAAA,GAAA,kBAKA,OADA,KAAA,OAAA,OAAA,EAAA,EACA,KAAA,SAAA,UAAA,EAAA,GAAA,sDAiBA,OAXA,EAAA,KAAA,qBAAA,KAAA,OAAA,KAAA,IAAA,KAAA,oBAAA,EAAA,EAAA,CAAA,CAGA,EAAA,KAAA,SAAA,SAAA,KAAA,WAAA,KAAA,YAAA,EAAA,GAAA,gEAKA,KAAA,UAAA,EAAA,EAAA,CACA,KAAA,eAAA,EAAA,CACA,KAAA,YAAA,EACA,qDAaA,OAPA,EAAA,KAAA,qBAAA,KAAA,OAAA,KAAA,IAAA,KAAA,oBAAA,EAAA,EAAA,CAAA,CAGA,KAAA,OAAA,IAAA,EAAA,KAAA,WAAA,KAAA,YAAA,CACA,KAAA,UAAA,EAAA,EAAA,CACA,KAAA,eAAA,EAAA,CACA,KAAA,YAAA,EACA,2DAKA,IAAA,IAAA,EAAA,EAAA,EAAA,KAAA,WAAA,KAAA,YAAA,EAAA,IAAA,KAAA,OAAA,GAAA,YAMA,EAAA,EAAA,EAAA,GAAA,yCAEA,EAAA,IAAA,KAAA,OAAA,CACA,KAAA,OAAA,EACA,KAAA,SAAA,IAAA,SAAA,EAAA,OAAA,EAAA,WAAA,EAAA,WAAA,CACA,KAAA,oBAAA,uBClPuD,CAG3D,IAAM,EAAgB,GAAwC,CAC5D,IAAMC,EAAsB,EAAE,CAE9B,IAAK,GAAM,CAAC,EAAK,KAAQ,OAAO,QAAQ,EAAM,CAAE,CAC9C,IAAI,EAAU,EACR,EAAO,EAAI,MAAM,EAAS,CAAC,OAAO,QAAQ,CAC1C,EAAW,EAAK,KAAK,CAC3B,IAAK,IAAM,KAAO,EAChB,EAAW,EAAQ,GAAO,EAAQ,IAAQ,EAAE,CAE9C,EAAQ,GAAY,EAEtB,OAAO,GAIH,EAAkB,GACtB,OAAO,QAAQ,EAAM,CAAC,QACnB,CAAE,MAAA,GAAS,CAAC,EAAK,MAAY,CAC5B,MAAO,CACL,GAAG,GACF,GAAM,EAAY,EAAM,CAAG,EAAe,EAAuB,CAAG,EACtE,CACF,EACD,CAAE,MAAO,EAAE,CAAE,CACd,CAGG,EAAe,KAAO,IAAwC,CAClE,GAAI,aAAgB,WAClB,OAAO,EAET,GAAI,aAAgB,YAClB,OAAO,IAAI,WAAW,EAAK,CAE7B,GAAI,aAAgB,KAAM,CACxB,IAAM,EAAS,MAAM,EAAK,aAAa,CACvC,OAAO,IAAI,WAAW,EAAO,CAG/B,OAAO,IAAI,aAAa,CAAC,OAAO,EAAK,EAIjC,EAAe,KAAO,IAEM,CAChC,IAAMC,EAA4B,CAAE,MAAO,EAAE,CAAE,CAE/C,IAAK,GAAM,CAAC,EAAK,KAAU,OAAO,QAAQ,EAAK,MAAM,CACnD,GAAI,EAAY,EAAM,EAAI,UAAY,EACpC,EAAO,MAAM,GAAO,MAAM,EAAa,EAA4C,KAC9E,CACL,IAAM,EAAO,MAAM,EAAa,EAAkB,CAClD,EAAO,MAAM,GAAO,CAAE,KAAM,EAAK,OAAQ,CAI7C,OAAO,GAIH,EAAkB,GAA+C,CACrE,IAAM,GACJ,EACA,IAEA,OAAO,QAAQ,EAAK,MAAM,CAAC,QACxB,CAAC,CAAE,SAAS,GAAgB,CAAC,EAAK,KAAW,CAC5C,GAAM,CAAC,EAAU,GAAa,EAAoB,EAAM,CACpD,EAAoB,EAAO,EAAc,CACzC,CACE,CACE,KAAO,EAAuB,MAAQ,EACtC,OAAQ,EACT,EACA,OAAO,EAAc,EAAK,EAAuB,MAAQ,IAAI,UAAU,CACzE,CAEL,MAAO,CACL,CACE,MAAO,CACL,GAAG,GACF,GAAM,EACR,CACF,CACD,EACD,EAEH,CAAC,CAAE,MAAO,EAAE,CAAE,CAAE,GAAU,IAAI,CAC/B,CAEH,OAAO,EAAoB,EAAM,IAAI,CAAC,IAIlC,EAAa,KAAO,IACxB,EAAe,MAAM,EAAa,EAAe,EAAM,CAAC,CAAC,CAGrD,EAAkB,KAAO,IAAgD,CAC7E,IAAMC,EAAuB,EAAE,CAE/B,IAAK,GAAM,EAAG,KAAU,OAAO,QAAQ,EAAM,CAC3C,GAAI,EAAY,EAAM,CAAE,CACtB,IAAM,EAAS,MAAM,EAAgB,EAAuB,CAC5D,EAAO,KAAK,GAAG,EAAO,MAEtB,EAAO,KAAK,MAAM,EAAa,EAAkB,CAAC,CAItD,OAAO,GAcI,EAAgB,MAC3B,EACA,IACwB,CACxB,IAAM,EAAkB,GAAS,KAAO,EAAa,EAAM,CAAG,EACxD,EAAS,MAAM,EAAW,EAAgB,CAC1C,EAAe,GAAa,CAClC,EAAa,YAAY,KAAK,UAAU,EAAO,CAAC,CAChD,IAAM,EAAY,EAAa,UAAU,CAEnC,EAAa,GAAa,CAChC,EAAW,YAAY,EAAU,OAAO,CACxC,IAAM,EAAU,EAAW,UAAU,CAE/B,EAAc,MAAM,EAAgB,EAAgB,CAGpD,EACJ,EAAQ,OAAS,EAAU,OAAS,EAAY,QAAQ,EAAK,IAAQ,EAAM,EAAI,OAAQ,EAAE,CAGrF,EAAS,IAAI,WAAW,EAAY,CACtC,EAAS,EAEb,EAAO,IAAI,EAAS,EAAO,CAC3B,GAAU,EAAQ,OAElB,EAAO,IAAI,EAAW,EAAO,CAC7B,GAAU,EAAU,OAEpB,IAAK,IAAM,KAAO,EAChB,EAAO,IAAI,EAAK,EAAO,CACvB,GAAU,EAAI,OAGhB,OAAO,GAUI,EAAgB,MAC3B,EACA,IACwB,CAExB,GAAM,CAAE,UAAA,EAAW,YAAA,GAAgB,MAAA,QAAA,SAAA,CAAA,UAAA,GAAA,CAAA,GAAA,CAE7B,CAAE,UAAW,MAAM,EAAU,EAAS,CAAE,KAAM,GAAM,CAAC,CACrD,EAAa,EAGbC,EAAuB,EAAE,CAC/B,IAAK,GAAM,CAAE,UAAU,EAAY,CACjC,IAAM,EAAU,MAAM,EAAY,EAAS,EAAK,CAE1C,EAAiB,EAAK,QAAQ,MAAO,GAAG,CAC9C,EAAM,GAAkB,IAAI,WAAW,EAAQ,CAIjD,IAAK,GAAM,CAAC,EAAM,KAAY,OAAO,QAAQ,EAAc,CAAE,CAC3D,IAAM,EAAiB,EAAK,QAAQ,MAAO,GAAG,CAC9C,EAAM,GAAkB,EAI1B,OAAO,EAAc,EAAO,CAAE,KAAM,GAAM,CAAC,ECrL7C,KAAK,UAAY,KAAO,IAAuC,CAC7D,IAAM,EAAU,EAAM,KAEtB,GAAI,CACF,OAAQ,EAAQ,KAAhB,CACE,IAAK,cAAe,CAClB,GAAM,CAAE,SAAQ,eAAgB,MAAM,EAAU,EAAQ,KAAM,CAAE,KAAM,GAAM,CAAC,CACvEC,EAA2B,CAC/B,KAAM,cACN,GAAI,EAAQ,GACZ,OAAQ,CAAE,MAAO,EAA8B,cAAa,CAC7D,CACD,KAAK,YAAY,EAAS,CAC1B,MAGF,IAAK,cAAe,CAClB,IAAM,EAAS,MAAM,EAAY,EAAQ,KAAM,EAAQ,KAAK,CACtDA,EAA2B,CAC/B,KAAM,cACN,GAAI,EAAQ,GACZ,SACD,CACD,KAAK,YAAY,EAAU,CAAE,SAAU,CAAC,EAAO,CAAE,CAAC,CAClD,MAGF,IAAK,eAAgB,CACnB,IAAMC,EAAsC,EAAE,CACxCC,EAA2B,EAAE,CACnC,IAAK,IAAM,KAAQ,EAAQ,MAAO,CAChC,IAAM,EAAS,MAAM,EAAY,EAAQ,KAAM,EAAK,CACpD,EAAO,GAAQ,EACf,EAAU,KAAK,EAAO,CAExB,IAAMF,EAA2B,CAC/B,KAAM,eACN,GAAI,EAAQ,GACZ,SACD,CACD,KAAK,YAAY,EAAU,CAAE,SAAU,EAAW,CAAC,CACnD,MAGF,IAAK,gBAAiB,CACpB,IAAM,EAAS,MAAM,EAAc,EAAQ,KAAM,EAAQ,cAAc,CACjEA,EAA2B,CAC/B,KAAM,gBACN,GAAI,EAAQ,GACZ,SACD,CACD,KAAK,YAAY,EAAU,CAAE,SAAU,CAAC,EAAO,OAAO,CAAE,CAAC,CACzD,cAGG,EAAG,CACV,IAAMA,EAA2B,CAC/B,KAAM,QACN,GAAI,EAAQ,GACZ,MAAO,aAAa,MAAQ,EAAE,QAAU,OAAO,EAAE,CAClD,CACD,KAAK,YAAY,EAAS"}